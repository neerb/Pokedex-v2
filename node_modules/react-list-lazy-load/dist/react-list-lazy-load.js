'use strict';

var React = require('react');
var PropTypes = require('prop-types');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var proxyMethods = ['getOffset', 'getScroll', 'setScroll', 'getViewportSize', 'getScrollSize', 'getStartAndEnd', 'getItemSizeAndItemsPerRow', 'getSpaceBefore', 'getSizeOf', 'scrollTo', 'scrollAround', 'getVisibleRange'];

function requestPage(call, page, cb) {
  var promise = call(page, cb);

  if (promise && promise.then) {
    promise.then(function (res) {
      return cb(null, res);
    }).then(null, cb);
  }
}
/**
 * Like `.slice`, but doesn't care about array bounds.
 *
 * [0, 1].slice(1, 3) === [1]
 * eagerSlice([0, 1], 1, 3) === [1, undefined, undefined]
 */


function eagerSlice(list, start, end) {
  var sliced = [];

  for (var i = start; i < end; i++) {
    sliced.push(list[i]);
  }

  return sliced;
}
/**
 * Adds simple lazy loading to react-list.
 */


var LazyList = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(LazyList, _React$Component);

  function LazyList(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this._list = null;
    _this._loadingPages = {};
    _this.updateFrame = _this.updateFrame.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = LazyList.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updateScrollParent();
    this.updateFrame();
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.updateScrollParent();
    this.updateFrame();
  };

  _proto.updateScrollParent = function updateScrollParent() {
    var prev = this.scrollParent;
    var list = this.getList();
    this.scrollParent = list.scrollParent;

    if (prev === this.scrollParent) {
      return;
    }

    if (prev) {
      prev.removeEventListener('scroll', this.updateFrame);
    }

    if (this.props.onRequestPage) {
      this.scrollParent.addEventListener('scroll', this.updateFrame);
    }
  };

  _proto.getList = function getList() {
    return this._list;
  };

  _proto.isLoadingPage = function isLoadingPage(page) {
    return !!this._loadingPages[page];
  };

  _proto.itemNeedsLoad = function itemNeedsLoad(idx) {
    var _this$props = this.props,
        items = _this$props.items,
        pageSize = _this$props.pageSize;
    var page = Math.floor(idx / pageSize);
    return items[idx] != null || this.isLoadingPage(page);
  };

  _proto.updateFrame = function updateFrame() {
    var _this2 = this;

    var _this$props2 = this.props,
        pageSize = _this$props2.pageSize,
        loadMargin = _this$props2.loadMargin,
        items = _this$props2.items,
        length = _this$props2.length,
        onRequestPage = _this$props2.onRequestPage; // Item range that should be loaded right about now.

    var _this$getVisibleRange = this.getVisibleRange(),
        topItem = _this$getVisibleRange[0],
        bottomItem = _this$getVisibleRange[1];

    if (topItem === undefined || bottomItem === undefined) {
      return;
    }

    topItem = Math.max(topItem - loadMargin, 0);
    bottomItem = Math.min(bottomItem + loadMargin, length);
    var almostVisibleItems = eagerSlice(items, topItem, bottomItem);
    var unloadedPages = almostVisibleItems.reduce(function (pages, item, idx) {
      if (item == null) {
        var page = Math.floor((topItem + idx) / pageSize);

        if (!_this2.isLoadingPage(page) && pages.indexOf(page) === -1) {
          return [].concat(pages, [page]);
        }
      }

      return pages;
    }, []);
    unloadedPages.forEach(function (page) {
      _this2._loadingPages[page] = true;
      requestPage(onRequestPage, page, function () {
        // Always delete after completion. If there was an error, we can retry
        // later. If there wasn't, we don't need to keep this around :)
        delete _this2._loadingPages[page];
      });
    });
  };

  _proto.render = function render() {
    var _this3 = this;

    return /*#__PURE__*/React__default['default'].cloneElement(this.props.children, {
      ref: function ref(list) {
        _this3._list = list;
      }
    });
  };

  return LazyList;
}(React__default['default'].Component);

if (process.env.NODE_ENV !== 'production') {
  LazyList.propTypes = {
    /**
     * Total amount of items, on all pages.
     */
    length: PropTypes__default['default'].number.isRequired,

    /**
     * Items per page.
     */
    pageSize: PropTypes__default['default'].number,

    /**
     * When to begin loading the next page.
     */
    loadMargin: PropTypes__default['default'].number,

    /**
     * Loaded items. NULLs in this array indicate unloaded items.
     */
    items: PropTypes__default['default'].array,

    /**
     * Callback to begin loading a page.
     */
    onRequestPage: PropTypes__default['default'].func.isRequired
  };
}

LazyList.defaultProps = {
  pageSize: 25,
  loadMargin: 5
};
proxyMethods.forEach(function (name) {
  LazyList.prototype[name] = function () {
    var _this$getList;

    return (_this$getList = this.getList())[name].apply(_this$getList, arguments);
  };
});

module.exports = LazyList;
